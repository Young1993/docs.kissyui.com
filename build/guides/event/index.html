	<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>event基本介绍 - KISSY v5.0 Documentation</title>
	<link rel="shortcut icon" href="/5.0/assets/favicon.ico">
	<link rel="stylesheet" href="/5.0/assets/css/bootstrap.css">
	<link rel="stylesheet" href="/5.0/assets/css/component.css">
	<link rel="stylesheet" href="/5.0/assets/css/custom.css">
	<link rel="stylesheet" href="/5.0/assets/css/github.css"/>
	<script type="text/javascript" src="http://g.tbcdn.cn/kissy/k/1.4.2/seed-min.js" data-config="{combine:true}"></script>
	<script src="/5.0/assets/js/ace-editor/ace.js"></script>
	<script src="/5.0/assets/js/ajax-load.js"></script>
	<script type="text/javascript" src="/5.0/assets/js/qrcodejs/qrcode.min.js"></script>
	
</head>
<body>
	<div class="container" id="container">
		<header class="header clearfix">
	<div class="logo">
		<a href="/5.0">
			<img src="/5.0/assets/img/logo.png" alt="">
		</a>
	</div>
	<div class="search">
		<gcse:search></gcse:search>
	</div>
	<div id="header-toolbar"></div>
</header>
<script type="text/javascript">
	KISSY.use('toolbar,button,menubutton', function(S, Toolbar){
			new Toolbar({
				render : '#header-toolbar',
				children : [
					{
						content : 'Home',
						listeners : {
							click : function(){
								window.location.href ='/5.0';
							}
						}
					},
					{
						content : 'Quick Start',
						listeners : {
							click : function(){
								window.location.href ='/5.0/quick-start.html';
							}
						}
					},
					{
						content : 'Docs',
						xclass : 'menu-button',
						menu : {
							children : [
								{
									content : 'Guides',
									listeners : {
										click : function(){
											window.location.href ='/5.0/guides';
										}
									}
								},
								{
									content : 'API Docs',
									listeners : {
										click : function(){
											window.location.href ='/5.0/api';
										}
									}
								},{
									content : 'Demos',
									listeners : {
										click : function(){
											window.location.href ='/5.0/demos';
										}
									}
								}
							]
						},
						matchElWidth : false
					},
					{
						content : 'Contribute',
						listeners : {
							click : function(){
								window.location.href = 'https://github.com/kissyteam/kissy/blob/master/CONTRIBUTING.md';
							}
						}
					},
					{
						content : 'More',
						xclass : 'menu-button',
						menu : {
							children : [
								{
									content : 'FAQ',
									listeners : {
										click : function(){
											window.location.href ='/5.0/more/faq.html';
										}
									}
								},
								{
									content : 'Gallery',
									listeners : {
										click : function(){
											window.location.href = 'http://gallery.kissyui.com/';
										}
									}
								},
								{
									content : 'Kissy Blog',
									listeners : {
										click : function(){
											window.location.href = 'http://blog.kissyui.com/';
										}
									}
								},
								{
									content : 'KMC',
									listeners : {
										click : function(){
											window.location.href = 'https://github.com/daxingplay/grunt-kmc/blob/master/README.md';
										}
									}
								},
								{
									content : 'ABC',
									listeners : {
										click : function(){
											window.location.href = 'http://abc.f2e.taobao.net/';
										}
									}
								},
								{
									content : 'Clam',
									listeners : {
										click : function(){
											window.location.href = 'https://github.com/jayli/generator-clam/blob/master/README.md';
										}
									}
								}
							]
						},
						matchElWidth : false
					}
				]
			}).render();
		});
</script>
		<div class="row">
			<div class="col-md-9" id="main-content">
				<p></p>
<h1>event基本介绍</h1><p>Event 模块是KISSY最重要的模块之一，他包含自定义事件机制、事件对象封装、DOM事件封装、面向多终端的事件行为统一。下辖多个子模块，被Node、DOM、Base分别依赖。通常DOM事件无需直接引用event，只需use(&#39;node&#39;)即可。使用use(&#39;base&#39;)时也无需手动引入event。如果想单独使用自定义事件，则需要use(&#39;event&#39;)。</p>
<pre><code>KISSY.<span class="hljs-keyword">use</span>(<span class="hljs-string">'event'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,Event)</span></span>{
    <span class="hljs-comment">// Your code..    </span>
});
</code></pre><p>Event是一个复杂的概念，是观察者模式在浏览器端的实现。事件本质上是一个抽象的概念。是让程序具有面向切面编程的特性，通过事件注册来在原有逻辑的某个时机触发外部代码的逻辑。这种方式是最常见的JavaScript设计模式。也是模块之间解耦的最佳选择之一。</p>
<h2 id="1">Node 事件</h2><h3 id="1.1">事件绑定</h3><p>浏览器对DOM节点暴露了一些事件，比如常见的click、mouseover等。在KISSY中通过统一的事件绑定写法来处理事件回调：</p>
<pre><code>Event.on(<span class="hljs-string">'#foo'</span>,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// 其中this是原生节点</span>
    alert(<span class="hljs-string">'clicked : '</span>+<span class="hljs-keyword">this</span>.id);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});
</code></pre><p>上面的代码作用是：为 id 为 foo 的元素绑定 click 事件.当用户在该元素内部点击时, 则 alert 会弹出来.</p>
<p>回调函数返回 false 相当于调用了事件对象的 preventDefault() 以及 stopPropagation()</p>
<p>Node模块依赖了Event模块的DOM部分，因此和浏览器和DOM相关的事件可以通过引入Node来使用，不必再引入Event模块，即如果你只用到了DOM事件，你只需这样：</p>
<pre><code><span class="hljs-comment">// 这里不用再引入event模块</span>
KISSY.<span class="hljs-keyword">use</span>(<span class="hljs-string">'node'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,Node)</span></span>{
    Node.all(<span class="hljs-string">'.a'</span>).on(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span>{
        <span class="hljs-comment">// Your code...    </span>
    });
});
</code></pre><p>因此，Node节点中的on()方法和Event.on()功能一样，只是传参不一样。</p>
<p>Node 模块的 on 方法中的 this 关键字指向当前绑定事件的单个原生节点, 事件对象的 target 和 relatedTarget 也指向对应的原生节点,</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'d1'</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">'d'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'d2'</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">'d'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    KISSY.all(<span class="hljs-string">".d"</span>).on(<span class="hljs-string">"mouseenter"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span>{
        <span class="hljs-keyword">this</span>.id <span class="hljs-comment">// =&gt; d1 或者 d2</span>
        ev.target.id <span class="hljs-comment">// =&gt; d1 或者 d2</span>
        ev.relatedTarget <span class="hljs-comment">// =&gt; d1 或者 d2 或者 document.body</span>
                        <span class="hljs-comment">// 或者 document.documentElement</span>
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><p>需要的话可以在开始包装 this （需要的话同样包装 event.target）</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'d1'</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">'d'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">'d2'</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">'d'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    KISSY.all(<span class="hljs-string">".d"</span>).on(<span class="hljs-string">"mouseenter"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span>{
        <span class="hljs-keyword">var</span> self=KISSY.one(<span class="hljs-keyword">this</span>);
        self.attr(<span class="hljs-string">"id"</span>) <span class="hljs-comment">// =&gt; d1 或者 d2</span>
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><h3 id="1.2">事件分组</h3><p>on()函数支持事件分组，比如这段代码：</p>
<pre><code><span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(foo,<span class="hljs-string">'click.one'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><span class="hljs-comment">{
    alert('clicked : '+this.id);
}</span>);</span>

<span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(foo,<span class="hljs-string">'click.two'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><span class="hljs-comment">{
    alert('clicked 2 : '+this.id);
}</span>);</span>

<span class="hljs-keyword">Event</span>.<span class="hljs-keyword">remove</span>(foo,<span class="hljs-string">'.two'</span>);
</code></pre><p>给<code>#foo</code>绑定了两次事件，但每次事件都有一个标识，这时可以清除其中一个标识。</p>
<h3 id="1.3">绑定多个事件</h3><pre><code><span class="hljs-comment">// 绑定了两个事件</span>
Event.on(foo,<span class="hljs-string">'mouseenter mouseleave'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> </span>{
    DOM.toggleClass(<span class="hljs-keyword">this</span>,<span class="hljs-string">"enter"</span>);
});
</code></pre><p>上述代码的作用是：一开始 foo 节点没有 enter 样式类, 当鼠标进入时给该节点添加 enter 样式类, 当鼠标移出时把 enter 样式类去掉. 这样就达到了 hover 的效果.</p>
<h3 id="1.4">事件对象</h3><p>DOM 事件回调函数回传参数为e，注意 e 不是原生事件对象，是封装后的，这时e.target是裸的节点。除了preventDefault()和stopPropagation()之外，e还包含halt()方法，指停止事件加阻止默认行为。</p>
<pre><code>Event.<span class="hljs-keyword">on</span>(foo,<span class="hljs-string">'mouseup mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
    console.<span class="hljs-built_in">log</span>(event.<span class="hljs-built_in">type</span> +<span class="hljs-string">" occured"</span>);
});
</code></pre><p>这样就可以在绑定多事件时, 明确知道当前哪个事件触发了.</p>
<blockquote>
<p>KISSY 也对 mouseenter/mouseleave focusin/focusout 进行了兼容处理, 所有浏览器都可以使用这两个事件了.</p>
</blockquote>
<p>通过调用事件对象的halt()方法来阻止事件。 </p>
<pre><code><span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(a,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span><span class="hljs-comment">{
    // 等价于 e.preventDefault(); e.stopPropagation();
    e.halt();
}</span>);</span>
</code></pre><p>如果要抓取事件发生时对应的节点，需要通过<code>e.target</code>获取，注意，这里的target是原生节点，若有必要，需要转换为Node节点，比如</p>
<pre><code><span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(a,<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span><span class="hljs-comment">{
    var node = S.one(e.target);
    alert(node.html());
}</span>);</span>
</code></pre><h3 id="1.5">事件移除</h3><p>从符合匹配的 dom 节点中移去相应事件的事件处理器，用 on 绑定的事件处理器可以用 detach 解除绑定. 最简单的情况 detach(elem) 解除该元素上的所有绑定.</p>
<pre><code><span class="hljs-keyword">Event</span>.detach(foo);
</code></pre><p>上面的代码解除了 foo 元素上所有事件的事件处理器, 我们也可以解除某一个事件的全部事件处理器:</p>
<pre><code><span class="hljs-keyword">Event</span>.detach(foo,<span class="hljs-comment">'click');</span>
</code></pre><p>当时如果程序对同一事件指定了不同的事件处理器, 这时就需要后面两个参数了</p>
<pre><code><span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> <span class="hljs-comment">{
    alert('The quick brown fox jumps over the lazy dog.');
}</span>;</span>
<span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(foo,<span class="hljs-string">'click'</span>, handler);
<span class="hljs-keyword">Event</span>.detach(foo,<span class="hljs-string">'click'</span>, handler);
</code></pre><p>通过指定第三个参数, 我们可以保证该事件的其他事件处理器不受影响, 注意下面的代码则不会生效：</p>
<pre><code><span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> <span class="hljs-comment">{
    alert('The quick brown fox jumps over the lazy dog.');
}</span>;</span>
<span class="hljs-keyword">var</span> obj=<span class="hljs-comment">{x:1}</span>;
<span class="hljs-keyword">Event</span>.<span class="hljs-keyword">on</span>(foo,<span class="hljs-string">'click'</span>, handler,obj);

<span class="hljs-keyword">Event</span>.detach(foo,<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> <span class="hljs-comment">{
    alert('The quick brown fox jumps over the lazy dog.');
}</span>,<span class="hljs-title">obj</span>);</span>

<span class="hljs-keyword">Event</span>.detach(foo,<span class="hljs-string">'click'</span>, handler,<span class="hljs-comment">{x:1}</span>);
</code></pre><p>虽然后面的两个 detach 参数从字面上来看完全一样, 但是由于是不同的对象, 所有仍然不会生效. 如果需要解除特定的事件处理器, 我们需要同一个对象( 函数 )引用, 而不是恰好字面上相同的不同对象.</p>
<p>detach也可以用别名remove标识。<a href="/5.0/demos/event/detach.html">事件移除的Demo</a>。</p>
<blockquote>
<p>如果要解除特定的事件处理器 , detach 的参数必须和对应的 on 参数值相等( == )并且个数一致才能完成解除绑定的目标.</p>
</blockquote>
<h3 id="1.6">事件委托</h3><p>为符合匹配的 dom 节点的相应事件添加事件处理器, 并在该节点的子孙节点中匹配 filter 的节点上触发事件时调用.</p>
<p>该方法是 on 方法的增强. 当 on 方法被调用时, 符合选择器的元素被绑定事件处理器, 但如果新增符合要求的节点，就不会再触发事件, 即他们需要另外一次绑定, 例如</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"clickme"</span>&gt;</span>
        Click here
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre><p>绑定一个 click 事件的事件触发器：</p>
<pre><code><span class="hljs-keyword">var</span> clickme=Dom.<span class="hljs-keyword">get</span>(<span class="hljs-string">'.clickme'</span>);
Event.on(clickme,<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Your code..</span>
});
</code></pre><p>当该元素被点击时, 调用对应的事件处理器. 但是如果新加入一个元素：</p>
<pre><code>Node.one('body').append('&lt;<span class="hljs-keyword">div</span> <span class="hljs-type">class</span>=<span class="hljs-string">"clickme"</span>&gt;Another target&lt;/<span class="hljs-keyword">div</span>&gt;');
</code></pre><p>新元素匹配选择器 clickme ,但是他如果不再次 on , 则在他上面的点击不会有任何效果.</p>
<p>delegate 方法提供了解决方法, 如果这样调用：</p>
<pre><code>Event.delegate(<span class="hljs-built_in">document</span>,<span class="hljs-string">'click'</span>,<span class="hljs-string">'.clickme'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// Your code..</span>
});
</code></pre><p>这样，只要是在document内新增的节点，都会触发回调。可以使用 undelegate 来移除之前的绑定:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span>{
}

<span class="hljs-comment">// 绑定</span>
Event.delegate(<span class="hljs-built_in">document</span>,<span class="hljs-string">'click'</span>,<span class="hljs-string">'.clickme'</span>,d);

<span class="hljs-comment">// 解除绑定</span>
Event.undelegate(<span class="hljs-built_in">document</span>,<span class="hljs-string">'click'</span>,<span class="hljs-string">'.clickme'</span>,d);
</code></pre><blockquote>
<p>不能在 object , embed , applet 元素上注册事件. 事件处理器回调函数中 this 指向 scope (没指定指向绑定事件的元素), 传入的参数为 event , event.target 指向事件触发源, event.currentTarget 指向当前事件处理器调用所在的匹配 filter 的元素. 可以使用 stopPropagation() 来停止事件的向上冒泡, 这样就不会在同样符合 filter 条件的祖先节点上调用事件处理器.</p>
<p>因为 delegate 是在事件冒泡到代理元素后才开始处理的，那么通过 on 注册到代理元素的子节点的事件处理器已经被触发， 而无法被 delegate 绑定的事件处理器阻止 ( stopPropagation )，但 delegate 事件处理器可以阻止绑定到同一元素但是匹配元素在当前事件处理器之上的 delegate 事件处理器.</p>
<p>同样可以对 mouseenter , mouseleave 进行委托.<a href="/5.0/demos/event/delegate.html">事件委托的Demo</a></p>
</blockquote>
<h3 id="1.7">解除事件委托</h3><p>为符合匹配的 dom 节点的相应事件去除事件处理器</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span>{}

<span class="hljs-comment">// 解除委托</span>
Event.undelegate(<span class="hljs-built_in">document</span>,<span class="hljs-string">'click'</span>,<span class="hljs-string">'.clickme'</span>,d);
</code></pre><p>和 Event.detach 一样, 如果移除特定的委托事件处理器必须保证参数和调用 delegate 时保持一致</p>
<h3 id="1.8">特殊事件支持</h3><p>KISSY 对常见的DOM事件做了封装，包括原生浏览器不支持的事件。</p>
<ul>
<li>focusin，元素内部获得焦点</li>
<li>focusout，元素内部失去焦点</li>
<li>hashchange，浏览器的hash改变</li>
<li>valuechange，input的值改变</li>
<li>mouseenter，鼠标进入</li>
<li>mouseleave，鼠标移出</li>
<li>mousewheel，滚轮事件</li>
</ul>
<h3 id="1.9">focusin</h3><p>原生只有 ie 支持 focusin 事件，而 kissy 对这一事件进行了 兼容性处理。但一个元素获得焦点或者其子孙元素获得焦点时， focusin 会在该元素上触发（没被子孙元素阻止）。这就是和 focus 事件的区别之处 : 你可以在父元素上监控子元素的 focus 事件，即 focusin 事件支持冒泡.</p>
<p>这个事件常常和 focusout 一起使用. <a href="/5.0/demos/event/focusin_out.html">Demo</a></p>
<h3 id="2">fousout</h3><p>原生只有 ie 支持 focusout 事件，而 kissy 对这一事件进行了 兼容性处理 .但一个元素获得焦点或者其子孙元素获得焦点时， focusout 会在该元素上触发（没被子孙元素阻止）。这就是和 blur 事件的区别之处 : 你可以在父元素上监控子元素的 blur 事件，即 focusout 事件支持冒泡.</p>
<p><a href="/5.0/demos/event/focusin_out.html">focusout事件的demo</a>.</p>
<h3 id="2.1">hashchange</h3><p>目前除了 ie67 外都原生支持 hashchange 事件，kissy 对 ie67 也模拟兼容了该事件.当浏览器的 hash 值发生变化时会触发此事件，常常被用来实现单页面应用，因为当用户点击后退与前进进行浏览器导航时会引起 hash 变化.</p>
<p>此事件只能在当前 window 上注册，注册到其他类型元素上无效！ <code>hash</code> 值推荐为 <code>!/xx/</code> 形式, 前面用 <code>!/</code> 后面用 <code>/</code> 包起来，否则 ie67 可能有诡异现象.</p>
<pre><code><span class="hljs-keyword">var</span> $=Node.all;
$(<span class="hljs-built_in">window</span>).on(<span class="hljs-string">"hashchange"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// location.hash -&gt; 当前 hash 值</span>
});
</code></pre><h3 id="2.2">valuechange</h3><p>监控 input/textarea 的值变化，当值发生变化时在绑定元素上触发该事件。为什么不使用原生的 change keydown keyup</p>
<ul>
<li>change 只有在输入框失去焦点时触发.</li>
<li>keyup/down 对于国际语言的输入法不能全面支持（鼠标从输入法中选词）</li>
<li>keydown/up 需要过滤不可见字符</li>
<li>程序设值不可以触发原生事件</li>
<li>从浏览器自带的 input 自动提示列表中鼠标选择项，不会触发 keydown keyup，但 input 值变化</li>
<li>右键鼠标黏贴不能支持</li>
</ul>
<p>当输入框获得焦点，程序动态设值可触发 valuechange 事件，否则不触发该事件.</p>
<p>事件对象上会挂两个值</p>
<ul>
<li>prevVal，旧值 </li>
<li>newVal，新值</li>
</ul>
<p>此事件只能在 input 以及 textarea 上注册，注册到其他类型元素上无效！</p>
<pre><code>KISSY.Event.on(input,<span class="hljs-string">"valuechange"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span>{
    alert(e.prevVal); <span class="hljs-comment">// =&gt; 旧值</span>
    alert(e.newVal); <span class="hljs-comment">// =&gt; 新值</span>
});
</code></pre><p><a href="/5.0/demos/event/valuechange.html">Demo</a></p>
<h3 id="2.3">mousewheel</h3><p>对鼠标滚轮事件做了浏览器兼容性处理，支持mousewheel事件</p>
<h3 id="2.4">mouseenter &amp; mouseleave</h3><p>鼠标进入容器和移除容器的操作</p>
<h3 id="2.5">移动设备事件支持</h3><p>KISSY 对于移动设备做了统一的事件封装，这些事件包括：</p>
<ul>
<li>doubleTap，双触</li>
<li>singleTap，单触</li>
<li>tap，触屏</li>
<li>tapHold，长按</li>
<li>swipe，快速滑动</li>
<li>rotateStart，开始旋转</li>
<li>rotate，旋转</li>
<li>rotateEnd，旋转结束</li>
<li>pinchStart，开始缩放</li>
<li>pinch，缩放</li>
<li>pinchEnd，缩放结束</li>
<li>shake，摇一摇</li>
</ul>
<h3 id="2.6">doubleTap</h3><p>触屏双击事件，快速点击某个dom节点两次后触发，用法和普通DOM事件无异</p>
<pre><code>Event.<span class="hljs-keyword">on</span>(<span class="hljs-string">'#t'</span>, <span class="hljs-string">"singleTap doubleTap"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
    alert(<span class="hljs-keyword">e</span>.<span class="hljs-built_in">type</span> + <span class="hljs-string">' : fired'</span>);
});
</code></pre><ul>
<li><a href="/5.0/demos/event/tap.html">双击事件的Demo，在手机中打开此demo</a></li>
</ul>
<h3 id="2.7">singleTap</h3><p>触屏单击事件，和双击互斥，当快速点击某个 dom 节点一次（短时间没有再次点击）后触发，<a href="/5.0/demos/event/tap.html">demo</a></p>
<h3 id="2.8">tap</h3><p>触屏单击，当点击某个 dom 节点后触发， 和 singleTap 的不同支持载入： 触发 doubleTap 就不会触发 singleTap， 而触发 doubleTap 前会触发 tap，<a href="/5.0/demos/event/tap.html">demo</a>。</p>
<h3 id="2.9">tapHold</h3><p>触屏长按，当常按某个 dom 节点超过 1s 后触发，<a href="/5.0/demos/event/tap.html">Demo</a></p>
<h3 id="3">swipe</h3><p>触屏上当快速划过某个元素时触发，事件对象会挂载这几个属性：</p>
<ul>
<li>distance：Number，划过的距离</li>
<li>direction：String，滑动方向，可取值为left/right/up/down</li>
<li>duration：Number，滑动持续事件，单位秒</li>
</ul>
<pre><code>Event.on(<span class="hljs-string">'#t'</span>, <span class="hljs-string">"swipe"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>{
    <span class="hljs-keyword">if</span>(e.direction==<span class="hljs-string">'left'</span>){
        e.preventDefault();
    }
});
</code></pre><p><a href="/5.0/demos/event/swipe.html">在触屏设备中打开这个Demo</a></p>
<h3 id="3.1">rotateStart</h3><p>触屏上开始用双指旋转某个 dom 元素时出现，事件对象上会挂载这两个属性</p>
<ul>
<li>angle：Number，开始时双指的角度</li>
<li>rotation：Number，固定为0</li>
</ul>
<p><a href="/5.0/demos/event/rotate.html">在触屏设备中打开demo</a></p>
<h3 id="3.2">rotate</h3><p>触屏上用双指旋转某个 dom 元素时出现，事件对象挂载这两个属性</p>
<ul>
<li>angle：Number，开始时双指的角度</li>
<li>rotation：Number，双指和开始相比改变的角度值</li>
</ul>
<p>demo参照上一个例子。</p>
<h3 id="3.3">rotateEnd</h3><p>触屏上用双指旋转某个 dom 元素结束时触发</p>
<h3 id="3.4">pinchStart</h3><p>触屏上开始用双指调整某个 dom 元素大小时出现，事件对象挂载这些属性</p>
<ul>
<li>distance：Number，开始时双指的绝对距离</li>
<li>scale：Number，固定为1</li>
</ul>
<p><a href="/5.0/demos/event/pinch.html">在触屏设备中打开Demo</a></p>
<h3 id="3.5">pinch</h3><p>触屏上用双指调整某个 dom 元素大小时出现，事件对象包含：</p>
<ul>
<li>distance：Number，开始时双指的绝对距离</li>
<li>scale：Number，双指相对于开始调整时具体的倍数</li>
</ul>
<h3 id="3.6">pinchEnd</h3><p>触屏上用双指调整某个 dom 元素大小后触发</p>
<h3 id="3.7">shake</h3><p>摇一摇事件，当用户摇动设备后触发，前后左右在一定连续时间内以一定幅度摇动设备，<a href="/5.0/demos/event/shake.html">Demo</a></p>
<h3 id="3.8">移动终端事件和PC端的统一</h3><p>为了兼容移动与pc， kissy Event 提供手势事件的枚举：</p>
<ul>
<li>start：手势开始事件 Event.Gesture.start ，可认为 pc 上为 &#39;mousedown&#39; , 触屏为 &#39;touchstart&#39;</li>
<li>move：手势进行事件 Event.Gesture.move ，可认为 pc 上为 &#39;mousemove&#39; , 触屏为 &#39;touchmove&#39;</li>
<li>end：手势结束事件 Event.Gesture.end ，可认为 pc 上为 &#39;mouseup&#39; , 触屏为 &#39;touchend&#39;</li>
<li>tap：手势结束事件 Event.Gesture.tap ，可认为 pc 上为 &#39;click&#39; , 触屏为 &#39;tap&#39;</li>
<li>doubleTap：手势结束事件 Event.Gesture.doubleTap ，可认为 pc 上为 &#39;dblclick&#39; , 触屏为 &#39;doubleTap&#39;</li>
</ul>
<hr>
<h2 id="4.8">自定义事件</h2><p>事件本身是一个抽象概念，和平台无关、和设备无关、更和浏览器无关，浏览器只是使用“事件”的方法来触发特定的行为，进而触发某段网页逻辑。而常见的DOM事件诸如click,dbclick是浏览器帮我们实现的“特定行为”。而这里的“特定行为”就是触发事件的时机，是可以被重新定义的，原理上，事件都是需要精确的定义的，比如下面这个例子，我们定义了一个新事件：“初始化1秒后”</p>
<p>这里我们使用Base内嵌的事件对象来描述</p>
<pre><code><span class="hljs-comment">// 为了便于理解，这里用 add() 将代码隔离开</span>

<span class="hljs-comment">// 实现Klass内部的自定义事件</span>
KISSY.add(<span class="hljs-string">'klass'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,Base)</span></span>{
    <span class="hljs-comment">// Klass 是一个类，它在被实例化后1秒会触发一个事件"afterOneSecond"</span>
    <span class="hljs-keyword">var</span> Klass = Base.extend({
        initializer:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            <span class="hljs-keyword">var</span> <span class="hljs-keyword">self</span> = this;

            <span class="hljs-comment">// Your Code</span>
            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
                <span class="hljs-keyword">self</span>.fire(<span class="hljs-string">'afterOneSecond'</span>,{
                    a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span> <span class="hljs-comment">//挂两个回调属性</span>
                });
            },<span class="hljs-number">1000</span>);
        }
    },{<span class="hljs-comment">/*ATTRS*/</span>});

    <span class="hljs-keyword">return</span> Klass;
},{
    requires:[<span class="hljs-string">'base'</span>]    
});

<span class="hljs-comment">// 绑定自定义事件</span>
KISSY.<span class="hljs-keyword">use</span>(<span class="hljs-string">'klass'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,Klass)</span></span>{
    <span class="hljs-comment">// 初始化这个类</span>
    <span class="hljs-keyword">var</span> k = <span class="hljs-keyword">new</span> Klass();

    <span class="hljs-comment">// 绑定事件监听</span>
    k.on(<span class="hljs-string">'afterOneSecond'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span></span>{
        alert(<span class="hljs-string">'1秒后触发这里的逻辑'</span>);
        <span class="hljs-comment">// e.a === 1</span>
        <span class="hljs-comment">// e.b === 1</span>
    });
});
</code></pre><p>这是一个很纯粹的自定义事件（Base组件内置自定义事件机制），它有事件名称“afterOneSecond”，有事件的触发条件<code>self.fire(&#39;afterOneSecond&#39;)</code>，有事件的绑定，<code>k.on(&#39;afterOneSecond&#39;)</code>。这样这个事件就能顺利的发生，并被成功监听。在代码组织层面，一般<code>Klass</code>类中实现了事件命名、定义和实现，属于内聚的功能实现。而绑定事件时可以是Klass这段代码的用户，他不会去关心事件的具体实现，只要关心Klass&quot;暴露了什么事件可以让我绑定&quot;就可以了，这就是KISSY中使用自定义事件的用法。你可以通过Base来创建自定义事件。</p>

				<div id="disqus_thread"></div>
				<!-- 这个隐藏的a标签用于实现局部刷新时更新右侧sidebar的api链接 -->
				<a id="apilink" href="../../api/classes/Event.html" style="display:none;"></a>
			</div>
			<div class="col-md-3" id="sidebar">
				<a class="link-apidocs btn btn-primary" href="../../api/classes/Event.html">API Docs</a>
				<div class="panel panel-primary">
					<div class="panel-heading">
						<h3 class="panel-title">Outline</h3>
					</div>
					<div class="panel-body">
						<ul class="outline">
							<li class="level2"><a href="#1">Node 事件</a></li><li class="level3"><a href="#1.1">事件绑定</a></li><li class="level3"><a href="#1.2">事件分组</a></li><li class="level3"><a href="#1.3">绑定多个事件</a></li><li class="level3"><a href="#1.4">事件对象</a></li><li class="level3"><a href="#1.5">事件移除</a></li><li class="level3"><a href="#1.6">事件委托</a></li><li class="level3"><a href="#1.7">解除事件委托</a></li><li class="level3"><a href="#1.8">特殊事件支持</a></li><li class="level3"><a href="#1.9">focusin</a></li><li class="level3"><a href="#2">fousout</a></li><li class="level3"><a href="#2.1">hashchange</a></li><li class="level3"><a href="#2.2">valuechange</a></li><li class="level3"><a href="#2.3">mousewheel</a></li><li class="level3"><a href="#2.4">mouseenter &amp; mouseleave</a></li><li class="level3"><a href="#2.5">移动设备事件支持</a></li><li class="level3"><a href="#2.6">doubleTap</a></li><li class="level3"><a href="#2.7">singleTap</a></li><li class="level3"><a href="#2.8">tap</a></li><li class="level3"><a href="#2.9">tapHold</a></li><li class="level3"><a href="#3">swipe</a></li><li class="level3"><a href="#3.1">rotateStart</a></li><li class="level3"><a href="#3.2">rotate</a></li><li class="level3"><a href="#3.3">rotateEnd</a></li><li class="level3"><a href="#3.4">pinchStart</a></li><li class="level3"><a href="#3.5">pinch</a></li><li class="level3"><a href="#3.6">pinchEnd</a></li><li class="level3"><a href="#3.7">shake</a></li><li class="level3"><a href="#3.8">移动终端事件和PC端的统一</a></li><li class="level2"><a href="#4.8">自定义事件</a></li>
						</ul>
					</div>
				</div>
				<div class="panel panel-primary ajax-load">
					<div class="panel-heading">
						<h3 class="panel-title">Features</h3>
					</div>
					<div class="panel-body">
						<p><a href="../../guides/event/index.html">event基本介绍</a></p>
					</div>
				</div>
				<div class="panel panel-primary ajax-load">
					<div class="panel-heading">
						<h3 class="panel-title">Demos</h3>
					</div>
					<div class="panel-body">
						<p><a href="../../demos/event/delegate.html">事件委托</a></p><p><a href="../../demos/event/detach.html">事件移除</a></p><p><a href="../../demos/event/focusin_out.html">focusin/focusout</a></p><p><a href="../../demos/event/pinch.html">pinch</a></p><p><a href="../../demos/event/rotate.html">rotate</a></p><p><a href="../../demos/event/shake.html">shake</a></p><p><a href="../../demos/event/swipe.html">swipe</a></p><p><a href="../../demos/event/tap.html">tap</a></p><p><a href="../../demos/event/valuechange.html">valuechange</a></p>
					</div>
				</div>
			</div>
			<div id="disqus_thread"></div>
<script>
    if((window.location.hostname.indexOf("kissyui.com")!=-1 )&& window.localStorage.getItem("kissy-commment")!="0"){
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'kissy-docs'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
     //var disqus_identifier = '/anim';
     //var disqus_url = window.location;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    }
</script>
<script>
    window.onload = function(){
        (function() {
        var cx = '003618533255763067140:5nkycw1pbey';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//www.google.com/cse/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    }
</script>
		</div>
	</div>
</body>
</html>