	<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>KISSY 模块定义规范（KMD） - KISSY v5.0 Documentation</title>
	<link rel="shortcut icon" href="/5.0/assets/favicon.ico">
	<link rel="stylesheet" href="/5.0/assets/css/bootstrap.css">
	<link rel="stylesheet" href="/5.0/assets/css/component.css">
	<link rel="stylesheet" href="/5.0/assets/css/custom.css">
	<link rel="stylesheet" href="/5.0/assets/css/github.css"/>
	<script type="text/javascript" src="http://g.tbcdn.cn/kissy/k/1.4.2/seed-min.js" data-config="{combine:true}"></script>
	<script src="/5.0/assets/js/ace-editor/ace.js"></script>
	<script src="/5.0/assets/js/ajax-load.js"></script>
	<script type="text/javascript" src="/5.0/assets/js/qrcodejs/qrcode.min.js"></script>
	
</head>
<body>
	<div class="container" id="container">
		<header class="header clearfix">
	<div class="logo">
		<a href="/5.0">
			<img src="/5.0/assets/img/logo.png" alt="">
		</a>
	</div>
	<div class="search">
		<gcse:search></gcse:search>
	</div>
	<div id="header-toolbar"></div>
</header>
<script type="text/javascript">
	KISSY.use('toolbar,button,menubutton', function(S, Toolbar){
			new Toolbar({
				render : '#header-toolbar',
				children : [
					{
						content : 'Home',
						listeners : {
							click : function(){
								window.location.href ='/5.0';
							}
						}
					},
					{
						content : 'Quick Start',
						listeners : {
							click : function(){
								window.location.href ='/5.0/quick-start.html';
							}
						}
					},
					{
						content : 'Docs',
						xclass : 'menu-button',
						menu : {
							children : [
								{
									content : 'Guides',
									listeners : {
										click : function(){
											window.location.href ='/5.0/guides';
										}
									}
								},
								{
									content : 'API Docs',
									listeners : {
										click : function(){
											window.location.href ='/5.0/api';
										}
									}
								},{
									content : 'Demos',
									listeners : {
										click : function(){
											window.location.href ='/5.0/demos';
										}
									}
								}
							]
						},
						matchElWidth : false
					},
					{
						content : 'Contribute',
						listeners : {
							click : function(){
								window.location.href = 'https://github.com/kissyteam/kissy/blob/master/CONTRIBUTING.md';
							}
						}
					},
					{
						content : 'More',
						xclass : 'menu-button',
						menu : {
							children : [
								{
									content : 'FAQ',
									listeners : {
										click : function(){
											window.location.href ='/5.0/more/faq.html';
										}
									}
								},
								{
									content : 'Gallery',
									listeners : {
										click : function(){
											window.location.href = 'http://gallery.kissyui.com/';
										}
									}
								},
								{
									content : 'Kissy Blog',
									listeners : {
										click : function(){
											window.location.href = 'http://blog.kissyui.com/';
										}
									}
								},
								{
									content : 'KMC',
									listeners : {
										click : function(){
											window.location.href = 'https://github.com/daxingplay/grunt-kmc/blob/master/README.md';
										}
									}
								},
								{
									content : 'ABC',
									listeners : {
										click : function(){
											window.location.href = 'http://abc.f2e.taobao.net/';
										}
									}
								},
								{
									content : 'Clam',
									listeners : {
										click : function(){
											window.location.href = 'https://github.com/jayli/generator-clam/blob/master/README.md';
										}
									}
								}
							]
						},
						matchElWidth : false
					}
				]
			}).render();
		});
</script>
		<div class="row">
			<div class="col-md-9" id="main-content">
				<h1>KISSY 模块定义规范（KMD）</h1><hr>
<p>模块：即一段独立成文件的代码单元。最常见的浏览器端 JavaScript 单元是：</p>
<pre><code><span class="hljs-comment">// within a file</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(doc)</span></span>{
    <span class="hljs-comment">// 模块代码</span>
})(<span class="hljs-built_in">document</span>);
</code></pre><p>这段代码用闭包来约束执行上下文，避免对全局命名空间的污染。随着代码复杂度增加，模块格式开始融入团队协作和性能要求，模块格式也从单纯的<code>匿名闭包函数</code>演变为<code>模块定义规范</code>。</p>
<p>首先要明确，模块化的目标是：</p>
<ol>
<li>代码单元冠以命名，增强代码段的辨识度</li>
<li>建立代码之间的依赖关系，降低代码段之间的耦合</li>
<li>命名空间和上下文管理，减少代码段之间的相互冲突</li>
<li>形成模块规范，提高代码段的复用性</li>
</ol>
<p>因此，一个完整的模块应当包含这几个属性</p>
<ol>
<li>模块名</li>
<li>实现逻辑</li>
<li>返回值</li>
<li>所依赖的模块</li>
</ol>
<p>KISSY 在诞生之初就确立了模块化的架构，以此抽象出现在的 KISSY 模块定义规范（KISSY Module Defination，简称 KMD）。这份规范明确了 KISSY 所遵循的书写格式和基本交互。</p>
<h1>API 规范</h1><h2>add() <code>Function</code></h2><p><code>add</code>函数挂载在全局对象<code>KISSY</code>上，用来定义模块。</p>
<pre><code><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(name?,factory?,deps)</span></span>
</code></pre><p>其中字符串<code>name</code>表示模块的注册名称，<code>factory</code>表示模块的主内容/逻辑，<code>deps</code>是一个对象，表示模块依赖</p>
<h3>add(name,factory)</h3><p><code>add</code>函数第一个参数是<code>name</code>，表示要注册模块的名字，<code>factory</code>可以是函数，也可以是对象或字符串。</p>
<p><code>factory</code>为函数时，表示模块的实现逻辑，回调函数回传第一个参数总是<code>KISSY</code>全局对象，约定写为<code>S</code>，该函数的返回值即为模块的返回值，该返回值将会传入调用这个模块的沙箱中：</p>
<pre><code>add(<span class="hljs-string">'module-name'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 模块代码</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'foo'</span>:<span class="hljs-string">'bar'</span>
    };
});
</code></pre><p><code>factory</code>为对象或者字符串时，只表示该模块的内容就是此对象或字符串：</p>
<pre><code>add('module-name','I am a <span class="hljs-keyword">template</span>, <span class="hljs-type">My</span> <span class="hljs-type">Name</span> <span class="hljs-keyword">is</span> {{module-name}}');
add('module-name',{
    'foo':'bar'    
});
</code></pre><h3>add(name,factory,deps)</h3><p>当给<code>add</code>函数传入最后一个参数<code>deps</code>，这时<code>deps</code>表示该模块的依赖，其中<code>requires</code>属性是一个数组，数组元素可以是其他模块的名字<code>name</code>，也可以是指向模块的路径，<code>factory</code>如果是函数，则函数中的回传参数除第一个<code>S</code>（全局对象 KISSY）外依次对应每个模块的返回值：</p>
<pre><code>add(<span class="hljs-string">'module-name'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,A,B,C)</span></span>{
    <span class="hljs-comment">// 模块代码    </span>
    <span class="hljs-keyword">return</span> sth;
},{
    requires:[
        <span class="hljs-string">'mod-a'</span>,<span class="hljs-string">'mod-b'</span>,<span class="hljs-string">'mod-c'</span>
    ]
});
</code></pre><h3>add(factory,deps)</h3><p><code>name</code>参数可以省略，但仅限于一个 JS 文件包含一个<code>add()</code>（这时文件名可以用作模块名），如果一个文件包含多个<code>add()</code>，则必须为每个<code>add()</code>指定模块名，即<code>name</code>参数不可省略，比如：</p>
<pre><code><span class="hljs-comment">// a.js，这里的add()没有指定name</span>
add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// A 模块逻辑</span>
});

<span class="hljs-comment">// b.js</span>
add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,A)</span></span>{
    <span class="hljs-comment">// B 模块逻辑</span>
},{
    requires:[<span class="hljs-string">'path/to/a.js'</span>]    
});
</code></pre><p>而这种用法是错误的：</p>
<pre><code><span class="hljs-comment">// a.js，一个 JS 文件中包含了两段add()，且都没有指定模块名</span>
add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 逻辑段1</span>
});
add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 逻辑段2</span>
});
</code></pre><p>一个文件带有多个<code>add()</code>时，必须补全每个<code>add()</code>的<code>name</code>，比如正确的写法是：</p>
<pre><code><span class="hljs-comment">// a.js 一个 JS 文件包含多段add()，必须补全每个模块名称</span>
add(<span class="hljs-string">'mod-a'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 逻辑段A</span>
});
add(<span class="hljs-string">'mod-b'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 逻辑段B</span>
});
</code></pre><h3>add(factory)</h3><p>也可以选择 commonjs 的模块书写方式，这种写法仅限于一个 JS 文件包含一个<code>add()</code>（这时文件名可以用作模块名），例如</p>
<pre><code><span class="hljs-comment">// a/b.js</span>
KISSY.add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,require,exports,module)</span></span>{
    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">require</span>(<span class="hljs-string">'a/c'</span>);
    <span class="hljs-keyword">return</span> c; <span class="hljs-comment">// 或者 module.exports=c;</span>
});
</code></pre><p><code>require</code>的典型用法是改造这种代码</p>
<pre><code>// requires 的模块太多，一不小心就和 <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> 里的回调不对应了
KISSY.add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,A,B,C,D,E,F,G)</span></span>{
    // Your code...
},{requires:[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>,<span class="hljs-string">'g'</span>]});
</code></pre><p>有没有办法不用去肉眼找模块和变量的对应关系？有方法，KISSY 1.4.1 提供了<code>require</code></p>
<pre><code>KISSY.add(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S, require)</span></span>{
    <span class="hljs-keyword">var</span> A = <span class="hljs-built_in">require</span>(<span class="hljs-string">'a'</span>);
    <span class="hljs-keyword">var</span> B = <span class="hljs-built_in">require</span>(<span class="hljs-string">'b'</span>);
    <span class="hljs-keyword">var</span> C = <span class="hljs-built_in">require</span>(<span class="hljs-string">'c'</span>);
    <span class="hljs-comment">// Your code...</span>
});
</code></pre><h2>require() <code>Function</code></h2><p><code>require</code>函数挂载在全局对象<code>KISSY</code>上，用来获取已加载的模块的值。</p>
<h3>require(name)</h3><p>获取已经注册的模块的返回值，这里注意，要保证所有依赖的模块都已经注册过，<code>require()</code>函数才会正确返回，如果有未注册的模块，<code>require()</code>不会计算依赖并动态加载。该函数只是针对已经注册过模块起作用，是一种快捷调用模块返回值的方法：</p>
<pre><code><span class="hljs-comment">// 注册模块</span>
S.add(<span class="hljs-string">'a'</span>,{
    <span class="hljs-string">'foo'</span>:<span class="hljs-string">'bar'</span>    
});

<span class="hljs-comment">// 获取已经注册模块的值</span>
S.<span class="hljs-keyword">require</span>(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// =&gt; {'foo':'bar'}</span>
</code></pre><h2>use() <code>Function</code></h2><p><code>use</code>函数挂载在全局对象<code>KISSY</code>上，用来异步调用模块，并在模块加载完成后运行沙箱逻辑。</p>
<h3>use(name,sandbox)</h3><p><code>name</code>是一个字符串，表示要载入模块的名字（列表），如果有多个名字，则中间用逗号分隔，函数<code>sandbox</code>为加载并注册完成这些模块后的回调逻辑，带入第一个参数为<code>KISSY</code>全局对象，默认缩写为<code>S</code>，其他参数依次带入所载入的模块返回的对象。</p>
<pre><code><span class="hljs-keyword">use</span>(<span class="hljs-string">'mod-a, mod-b'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,ModA,ModB)</span></span>{
    <span class="hljs-comment">// 沙箱逻辑</span>
});
</code></pre><p>其中，<code>name</code>字段中的每个单元，可以用模块名称表示，也可以用模块文件对应的路径表示，这时，模块定义时的名称也应当和这里的路径保持一致，比如：</p>
<pre><code><span class="hljs-keyword">use</span>(<span class="hljs-string">'path/to/mod-a, path/to/mod-b'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,ModA,ModB)</span></span>{
    <span class="hljs-comment">// 沙箱逻辑    </span>
});
</code></pre><p>例子中的模块 A 和模块 B 在注册模块名时的书写方法请参照<code>add()</code>。</p>
<h2>config() <code>Function</code></h2><p><code>config</code>函数挂载在全局对象<code>KISSY</code>上，用来读写全局配置项，包括注册<strong>包</strong>、预注册<strong>模块</strong>名称，模块文件的引用规则等等。</p>
<h3>config(name,pkg)</h3><p>写配置项，<code>name</code>表示配置项名称，<code>pkg</code>表示配置项的值，其中配置项包括：</p>
<ul>
<li>modules，JSON 对象，预注册的模块关系依赖</li>
<li>combine，Boolean值，是否开启动态合并</li>
<li>comboMaxFileNum，数字类型，动态合并文件最大个数，默认 40</li>
<li>comboMaxUrlLength，数字类型，动态合并后产生的 url 最大长度，默认 2000</li>
<li>packages，JSON 对象，包配置</li>
<li>tag，字符串，异步加载文件时所带的时间戳</li>
<li>debug，Boolean值，是否开启debug模式，不开启，将默认加载<code>&#39;-min&#39;</code>文件</li>
<li>charset，字符串，指示所有模块文件编码格式，默认为<code>utf-8</code></li>
<li>base，字符串，类库所在的URL</li>
</ul>
<p><strong>注册包</strong>：包是一个名字，用来映射某个URL地址，方便记忆和引用，比如：</p>
<pre><code><span class="hljs-comment">// 配置包</span>
config(<span class="hljs-string">'packages'</span>,{
    <span class="hljs-string">'pkg-name'</span>:{
        base:<span class="hljs-string">'http://path/to/project/'</span>
    }
});

<span class="hljs-comment">// 使用包下辖的模块，载入了 http://path/to/project/pkg-name/a.js</span>
<span class="hljs-keyword">use</span>(<span class="hljs-string">'pkg-name/a'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,A)</span></span>{
    <span class="hljs-comment">// 沙箱逻辑    </span>
});
</code></pre><p>使用<code>ignorePackageNameInUri</code>属性来说明是否在请求模块路径中省去<code>pkg-name</code>，比如下面代码也是正确的：</p>
<pre><code><span class="hljs-comment">// 配置包</span>
config(<span class="hljs-string">'packages'</span>,{
    <span class="hljs-string">'pkg-name'</span>:{
        base:<span class="hljs-string">'http://path/to/project/pkg-name/'</span>,
        ignorePackageNameInUri:<span class="hljs-literal">true</span>
    }
});

<span class="hljs-comment">// 使用包下辖的模块，载入了 http://path/to/project/pkg-name/a.js</span>
<span class="hljs-keyword">use</span>(<span class="hljs-string">'pkg-name/a'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S,A)</span></span>{
    <span class="hljs-comment">// 沙箱逻辑    </span>
});
</code></pre><p>当开启了<code>combine:true</code>，可使用<code>group</code>属性来配置多个包之间的合并请求：</p>
<pre><code><span class="hljs-comment">// 配置包，并给定分组名 group</span>
config(<span class="hljs-string">'packages'</span>,{
    <span class="hljs-string">'pkg-a'</span>:{
        <span class="hljs-keyword">base</span>:<span class="hljs-string">'http://path/to/project/pkg-a/'</span>,
        <span class="hljs-keyword">group</span>:<span class="hljs-string">'my'</span>
    },
    <span class="hljs-string">'pkg-b'</span>:{
        <span class="hljs-keyword">base</span>:<span class="hljs-string">'http://path/to/project/pkg-b/'</span>,
        <span class="hljs-keyword">group</span>:<span class="hljs-string">'my'</span>
    },
});

<span class="hljs-comment">// 使用包下辖的模块</span>
use(<span class="hljs-string">'pkg-a/mod1,pkg-b/mod2'</span>,function(S){
    <span class="hljs-comment">// 沙箱逻辑    </span>
});
</code></pre><p>开启<code>combine:true</code>后，这条<code>use()</code>语句将只会发起一个 HTTP 请求，而非两个。</p>
<p><code>pkg-name</code>也可以用于<code>add()</code>函数，比如：</p>
<pre><code><span class="hljs-comment">// 注册模块文件 </span>
<span class="hljs-comment">// http://path/to/project/pkg-name/a.js</span>
add(<span class="hljs-string">'pkg-name/a'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{
    <span class="hljs-comment">// 模块 A 的逻辑    </span>
});
</code></pre><p><strong>预注册模块</strong>：由于浏览器端加载脚本都是异步，因此如果模块之间有依赖，主逻辑只能在加载 A 模块后才知道并加载 A 的依赖。因此加载过程为串行。为了降低串行的性能损耗，<code>config()</code>可以预先注册模块的依赖关系，一次性加载模块和与之关联的依赖，比如</p>
<pre><code><span class="hljs-comment">// 预注册模块依赖</span>
config('modules',{
    'mod-a':{
        requires:['mod-b<span class="hljs-string">','</span><span class="hljs-keyword">mod</span>-c']
    },
    'mod-b':{
        requires:['mod-d<span class="hljs-string">','</span><span class="hljs-keyword">mod</span>-e']
    }
});

<span class="hljs-comment">// use() 模块时，在配置了 combine:true 后，将会合并载入模块及其依赖</span>
<span class="hljs-keyword">use</span>('mod-a, <span class="hljs-keyword">mod</span>-b', function(S,ModA,ModB){
    <span class="hljs-comment">// 沙箱逻辑    </span>
});
</code></pre><p><strong>模块别名</strong>：在定义模块时，可以通过<code>alias</code>来定义模块别名</p>
<pre><code><span class="hljs-comment">// 定义模块的别名</span>
config(<span class="hljs-string">'modules'</span>,{
    <span class="hljs-string">'mod-a'</span>:{
        alias:[<span class="hljs-string">'mod-b/1.2'</span>] <span class="hljs-comment">// 数组长度为1</span>
    }
});

<span class="hljs-comment">// 正常使用模块</span>
<span class="hljs-keyword">use</span>(<span class="hljs-string">'mod-a'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(S)</span></span>{});
</code></pre><h3>config(cfg)</h3><p>写配置项的另外一种写法，即传入一个JSON对象<code>cfg</code>：</p>
<pre><code>config({
    modules:{
        // 模块依赖关系Map
    },
    packages:{
        // 包配置
    },
    combine:true,
    charset:<span class="hljs-string">'utf-8'</span>,
    debug:false
    //<span class="hljs-keyword">...</span>
});
</code></pre><h3>config(name)</h3><p>读配置项</p>
<pre><code><span class="hljs-comment">// 获取当前的全局配置</span>
<span class="hljs-keyword">var</span> combine = config(<span class="hljs-string">'combine'</span>);
</code></pre><h2>小结</h2><p>以上为 KMD 模块定义规范的全部内容，经常使用的 API 只有 <code>use</code>、<code>add</code>、<code>config</code>。</p>
<p>KMD 规范诞生之初还未有<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS规范</a>以及<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> 和 <a href="https://github.com/seajs/seajs/issues/242">CMD</a>。经典的 <a href="http://yuilibrary.com/yui/docs/yui/loader.html">YUI3 Loader</a> 受限于单一的业务场景（门户网站），至今未完全形成规范。KMD 作为一个完整的模块规范，崇尚约定，保持简单，并在 Loader 的实现过程中，新增了别名、包配置、动态combo等实际工作中常用的功能，即有别于 AMD 和 CMD 的过于纯粹，又不同于 YUILoader 的繁杂配置，保持其易用和实用。</p>

				<div id="disqus_thread"></div>
				<!-- 这个隐藏的a标签用于实现局部刷新时更新右侧sidebar的api链接 -->
				<a id="apilink" href="../../api" style="display:none;"></a>
			</div>
			<div class="col-md-3" id="sidebar">
				<a class="link-apidocs btn btn-primary" href="../../api">API Docs</a>
				<div class="panel panel-primary">
					<div class="panel-heading">
						<h3 class="panel-title">Features</h3>
					</div>
					<div class="panel-body">
						<p><a href="../../guides/loader/alias.html">KISSY Loader 的别名机制</a></p><p><a href="../../guides/loader/import-style.html">importStyle的使用</a></p><p><a href="../../guides/loader/index.html">loader基本介绍</a></p><p><a href="../../guides/loader/kmd.html">KISSY 模块定义规范（KMD）</a></p><p><a href="../../guides/loader/timestamp.html">使用 KISSY Loader 管理时间戳</a></p>
					</div>
				</div>
				<div class="panel panel-primary">
					<div class="panel-heading">
						<h3 class="panel-title">Demos</h3>
					</div>
					<div class="panel-body">
						<p><a href="../../demos/loader/index.html">Classic Loader 简单配置包使用</a></p>
					</div>
				</div>
			</div>
			<div id="disqus_thread"></div>
<script>
    if((window.location.hostname.indexOf("kissyui.com")!=-1 )&& window.localStorage.getItem("kissy-commment")!="0"){
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'kissy-docs'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
     //var disqus_identifier = '/anim';
     //var disqus_url = window.location;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    }
</script>
<script>
    window.onload = function(){
        (function() {
        var cx = '003618533255763067140:5nkycw1pbey';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//www.google.com/cse/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    }
</script>
		</div>
	</div>
</body>
</html>